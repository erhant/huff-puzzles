
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can; 
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

#define function pushh(uint256 num) payable returns()
#define function popp() payable returns()
#define function read(uint256 index) payable returns(uint256)
#define function length() payable returns(uint256)
#define function write(uint256 index, uint256 num) payable returns()

#define error OutOfBounds()
#define error ZeroArray()

#define macro MAIN() = {
    // function selectors
    0x00 calldataload 0xE0 shr
    dup1 __FUNC_SIG(pushh)  eq pushh_func  jumpi
    dup1 __FUNC_SIG(popp)   eq popp_func   jumpi
    dup1 __FUNC_SIG(read)   eq read_func   jumpi
    dup1 __FUNC_SIG(length) eq length_func jumpi
         __FUNC_SIG(write)  eq write_func  jumpi

    // unrecognized function
    0x00 0x00 revert

    // functions
    pushh_func:
        PUSH()
    popp_func:
        POP()
    read_func:
        READ()
    length_func:
        LENGTH()
    write_func:
        WRITE()

    // error returns
    outOfBounds_error:
        __ERROR(OutOfBounds) 0x00 mstore
        0x04 0x00 revert

   zeroArray_error:
        __ERROR(ZeroArray) 0x00 mstore
        0x04 0x00 revert
}

#define macro PUSH() = {
    LEN()             // [i]

    // store value
    0x04 calldataload // [i, v]
    dup2              // [i, v, i]
    sstore            // [i]

    // increment index
    0x01 add          // [i+1]
    0x00 sstore

    0x00 0x00 return
}

#define macro POP() = {
    LEN()             // [i]

    // decrement index
    0x01 swap1        // [1, i]
    sub               // [i-1]
    0x00 sstore       // []

    // revert if zero
    dup1 iszero       // [i, i, i == 0]
    zeroArray_error jumpi

    // load value
    sload             // [i, v]
    0x00 mstore       // [i]

    

    // returns `v`
    0x20 0x00 return
}

#define macro READ() = {
    PTR()         // [i]

    // check if valid
    // load

    // return `v`
    sload         // [v]
    0x00 mstore   // []
    0x20 0x00 return
}

#define macro LENGTH() = {
    LEN()         // [i]
    0x00 mstore   // []
    0x20 0x00 return
}

#define macro WRITE() = {
    
}

#define macro LEN() = returns(1) {
    // length is stored in slot 0
    0x00 sload
}

#define macro CHECK_VALID() = {
    0x00 sload
}